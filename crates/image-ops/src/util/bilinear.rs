const EPSILON: f32 = 0.0001;
const ZERO_TO_ONE: std::ops::RangeInclusive<f32> = EPSILON..=(1.0 - EPSILON);

#[derive(Debug, Clone, Copy)]
pub struct BiLinear {
    pub x0y0: f32,
    pub x1y0: f32,
    pub x0y1: f32,
    pub x1y1: f32,
}

// NOTE: In the following comments, I will often use the term "image". What I mean is the image that can generated by
// sampling `BiLinear` at all x,y in 0..=1. The resulting square image can then saving as a e.g. 400x400px image.
// I used this approach to study this problem, and would recommend it to anyone who wants to understand the code below.

impl BiLinear {
    #[allow(dead_code)]
    pub fn new(x0y0: f32, x1y0: f32, x0y1: f32, x1y1: f32) -> Self {
        Self {
            x0y0,
            x1y0,
            x0y1,
            x1y1,
        }
    }

    #[inline]
    pub fn sample(self, x: f32, y: f32) -> f32 {
        let y0 = self.x0y0 + (self.x1y0 - self.x0y0) * x;
        let y1 = self.x0y1 + (self.x1y1 - self.x0y1) * x;
        y0 + (y1 - y0) * y
    }

    #[allow(dead_code)]
    pub fn sample_for_x(self, x: f32) -> impl Fn(f32) -> f32 {
        let y0 = self.x0y0 + (self.x1y0 - self.x0y0) * x;
        let y1 = self.x0y1 + (self.x1y1 - self.x0y1) * x;
        let y_diff = y1 - y0;
        move |y| y0 + y_diff * y
    }
    #[allow(dead_code)]
    pub fn sample_for_y(self, y: f32) -> impl Fn(f32) -> f32 {
        let x0 = self.x0y0 + (self.x0y1 - self.x0y0) * y;
        let x1 = self.x1y0 + (self.x1y1 - self.x1y0) * y;
        let x_diff = x1 - x0;
        move |x| x0 + x_diff * x
    }

    /// Returns the image from x in 0..=0.5 and y in 0..=0.5
    pub fn get_first_quadrant(self) -> BiLinear {
        BiLinear {
            x0y0: self.sample(0.0, 0.0),
            x1y0: self.sample(0.5, 0.0),
            x0y1: self.sample(0.0, 0.5),
            x1y1: self.sample(0.5, 0.5),
        }
    }
    /// Mirrors the image along the (0,0) -> (1,1) diagonal.
    #[allow(dead_code)]
    #[inline]
    pub fn mirror(self) -> BiLinear {
        BiLinear {
            x0y0: self.x0y0,
            x1y0: self.x0y1,
            x0y1: self.x1y0,
            x1y1: self.x1y1,
        }
    }

    /// Approximates `get_area` by sampling points in the image along a grid.
    ///
    /// `SAMPLES_SQRT` determines the size of the grid. E.g. for `SAMPLES_SQRT=8`, 8*8=64 samples will be taken.
    ///
    /// The max error is guaranteed to be less than `1/SAMPLES_SQRT`. Yes, this bound is pretty bad. The average error
    /// is around `0.1/(SAMPLES_SQRT*ln(SAMPLES_SQRT))`.
    #[allow(dead_code)]
    fn get_area_samples<const SAMPLES_SQRT: usize>(self, threshold: f32) -> f32 {
        let mut area: usize = 0;

        for y in 0..SAMPLES_SQRT {
            let y = (y as f32 + 0.5) / SAMPLES_SQRT as f32;
            let sample = self.sample_for_y(y);
            for x in 0..SAMPLES_SQRT {
                let x = (x as f32 + 0.5) / SAMPLES_SQRT as f32;
                if sample(x) > threshold {
                    area += 1;
                }
            }
        }

        area as f32 / (SAMPLES_SQRT * SAMPLES_SQRT) as f32
    }
    /// Approximates `get_area` by numerically approximating the integral.
    ///
    /// `SAMPLES` determines the number of thin slices used to approximate the integral.
    ///
    /// The average error is around `0.04/(SAMPLES**1.666)`.
    #[allow(dead_code)]
    fn get_area_numerical_integration<const SAMPLES: usize>(mut self, threshold: f32) -> f32 {
        // NOTE: the current approach is not ideal. I know that there is a pure analytical solution to this problem,
        // but I am not smart enough to derive it. When looking at different images, it is clear that the function that
        // describes the edge of the thresholded image is a simple 1/x function, just scaled and moved around a bit.
        // Ignoring edges cases where the scale is close to 0 or Infinity, it should be possible to find the parameters
        // of this function and then to solve the integral. I just don't know how to figure out the parameters.

        // since we can mirror the image while preserving area, we can choose the axis over which we want to integrate.
        // we choose an axis by looking at how much our end points differ.
        let diff_x = (self.x0y0 - self.x1y0).abs() + (self.x0y1 - self.x1y1).abs();
        let diff_y = (self.x0y0 - self.x0y1).abs() + (self.x1y0 - self.x1y1).abs();
        if diff_x < diff_y {
            self = self.mirror()
        }

        // we can rewrite the sample function as:
        //   sample(x,y) = x*y*a + x*b + y*c + d
        // for the following values of a,b,c,d:
        let a = self.x1y1 - self.x1y0 - self.x0y1 + self.x0y0;
        let b = self.x1y0 - self.x0y0;
        let c = self.x0y1 - self.x0y0;
        let d = self.x0y0 - threshold;

        // The idea here is that we will hold y constant, and then analytically solve the area for that thin strip.
        // We then integrate that area over all y values. Or rather, we approximate the integral.

        let area_for_y = |y: f32| {
            // We are searching for x such that x*y*a + x*b + y*c + d = t.
            // Since that x might not exist within the range 0..=1, we're gonna evaluate the points for x=0 and x=1, and then go from there
            let m = y * a + b;
            let x0 = y * c + d;
            let x1 = m + x0;

            if x0 <= 0.0 && x1 <= 0.0 {
                // the strip is entirely below the threshold
                return 0.0;
            }
            if x0 > 0.0 && x1 > 0.0 {
                // the strip is entirely above the threshold
                return 1.0;
            }

            // the strip is partially above the threshold
            let x = -x0 / m;
            if x0 > 0.0 {
                x
            } else {
                1.0 - x
            }
        };

        // integrate over y
        let mut area = 0.0;
        let sample_area = 1.0 / SAMPLES as f32;
        let sample_offset = sample_area / 2.0;

        for i in 0..SAMPLES {
            let y = i as f32 * sample_area + sample_offset;
            area += area_for_y(y) * sample_area;
        }

        area
    }

    /// Returns the percentage of the area of the image that is above the given threshold.
    ///
    /// The area is calculate exactly. Well, as exact as `f32` can be.
    pub fn get_area(self, threshold: f32) -> f32 {
        // we can rewrite the sample function as:
        //   sample(x,y) - threshold = x*y*a + x*b + y*c + d
        // for the following values of a,b,c,d:
        let a = self.x1y1 - self.x1y0 - self.x0y1 + self.x0y0;
        let b = self.x1y0 - self.x0y0;
        let c = self.x0y1 - self.x0y0;
        let d = self.x0y0 - threshold;

        // The function that describes the edge of the thresholded image is simply:
        //   x*y*a + x*b + y*c + d = 0
        // solving for y, we get:
        //   y = -(x*b + d) / (x*a + c) = f(x)
        // integrating dx, we get:
        //   F(x) = ((b*c - a*d) * Log(a*x + c) - a*b*x) / a^2
        // and to get the area between x=n and x=m, we simply do:
        //   area(n,m) = F(m) - F(n) = ((b*c - a*d) * (Log(a*m+c) - Log(a*n+c)) - a*b*(m-n)) / a^2
        //
        // Note that Log(x) is the complex-valued natural logarithm. Not to fear though, since a*x+c is a real-valued,
        // we can do a little trick. For negative value -z, Log(-z) = Log(z) + i*Pi. So if both a*m+c and a*n+c are
        // negative, the two i*Pi cancel out, and we get a real-valued result. Since we know that the area we're
        // looking for is real-valued, we can assume that a*m+c and a*n+c are always either both positive or both
        // negative. So ignoring the sign of the number under the Log, we get:
        //   area(n,m) = ((b*c - a*d) * (ln|a*m+c| - ln|a*n+c|) - a*b*(m-n)) / a^2
        //
        // We can now calculate the area, but we cannot use it directly. We don't actually want the area under the
        // curve f(x), but the area in *the intersection of the curve f(x) and the square 0..=1,0..=1*. To do that,
        // we need to find the intersection points of the curve with the square. This is pretty simple. In our case,
        // we only care about the intersection with sides y=0 and y=1. We can just solve for x to get the points.
        // In total, we can find 1 and 2 intersection points. However, we only care about intersection in x=0..1, and
        // we will always consider x=0 and x=1 intersection points, so there will be either 2, 3, or 4 intersection
        // points. This divides the square into 1, 2, or 3 areas that we will solve separately.

        // A small helper function for later. It will sample the point x=0.5,y=0.5 and return whether the sample is
        // above the threshold.
        let sample_middle = || 0.25 * a + 0.5 * b + 0.5 * c + d > 0.0;

        // Before we go any further, we have to handle zeros. If a is zero, then the function is linear (maybe).
        if a.abs() < EPSILON {
            // Our curve simplifies to:
            //   f(x) = -(x*b + d) / (x*a + c) = -(x*b + d) / c
            //   F(x) = -(b*x*x/2 + d*x) / c
            //   area(n,m) = (b/2*(n^2-m^2) + d*(n-m)) / c
            //
            // And we have to check for c=0 too
            if c.abs() < EPSILON {
                // This is an interesting case. The curve is either a straight line parallel to the y axis, or not a
                // curve at all. To figure this out, we have to change our perspective. So let's go back to the very
                // start and solve our initial equation for x instead of y:
                //   x*y*a + x*b + y*c + d = 0
                //   x = -(y*c + d) / (y*a + b) = g(y)
                // We know that a=c=0, so let's plug that in:
                //   g(y) = -d / b

                if b.abs() < EPSILON {
                    // b=0 is the case where all values in our images are the same value. This is the case where we don't
                    // have a curve at all. So the area of our thresholded image is either 1 or 0.
                    return if d > 0.0 { 1.0 } else { 0.0 };
                }

                // We now know that our curve is a straight line parallel to the y axis. Let's see where our line lies.
                let x = -d / b;
                // we need to sample a point left of the line, so we just take x=x-1,y=0.
                //   sample(x=x-1, y=0) - threshold = x*y*a + x*b + y*c + d = (x-1)*b + d
                let sample = (x - 1.0) * b + d;
                let area = x.clamp(0.0, 1.0);
                return if sample > 0.0 { area } else { 1.0 - area };
            }

            // We now know that we are dealing with a regular linear function. Nothing fancy.
            // Except... we need to check for intersections with the square 0..=1,0..=1, and that will be difficult if
            // the linear function parallel to the x axis. So we need to check for that.
            if b.abs() < EPSILON {
                // We are now dealing with the following function:
                //   f(x) = -(x*b + d) / c = -d / c
                // This is the same as the previous parallel straight-line case.
                let y = -d / c;
                // we need to sample a point left of the line, so we just take x=0,y=y-1.
                //   sample(x=0, y=y-1) - threshold = x*y*a + x*b + y*c + d = (y-1)*c + d
                let sample = (y - 1.0) * c + d;
                let area = y.clamp(0.0, 1.0);
                return if sample > 0.0 { area } else { 1.0 - area };
            }

            // No more surprises now. We have a linear function, and it even intersects the lines y=0 and y=1. Let's
            // do that. The formula is simple:
            //   x = -(y*c + d) / b
            let x_y0 = (-d / b).clamp(0.0, 1.0);
            let x_y1 = (-(c + d) / b).clamp(0.0, 1.0);
            if (x_y0 - x_y1).abs() < EPSILON {
                // The line does *not* intersect the square we're interested in. So the area is either 0 or 1.
                // we can't use any of the corner points as samples this time.
                return if sample_middle() { 1.0 } else { 0.0 };
            }

            let mut area: f32 = 0.0;

            // sort the intersection points
            let i_min = x_y0.min(x_y1);
            let i_max = x_y0.max(x_y1);

            // area under the line: area(i_min, i_max)
            let line_area = (0.5 * b * (i_min * i_min - i_max * i_max) + d * (i_min - i_max)) / c;
            // figure out whether the area of the line is above the threshold
            //   sample(x=x_y1, y=0) - threshold = x*y*a + x*b + y*c + d = x_y1*b + d
            area += if x_y1 * b + d > 0.0 {
                line_area
            } else {
                let total_line_area = i_max - i_min;
                total_line_area - line_area
            };

            // and now the bits before and after the line (if any)
            // For the stuff before i_min, we need to check sample(x=0,y=0)-threshold, which is exactly d
            if d > 0.0 {
                area += i_min;
            }
            // For the stuff after i_max, we need to check sample(x=1,y=0)-threshold, which is b+d
            if b + d > 0.0 {
                area += 1.0 - i_max;
            }

            return area;
        }

        // Okay, linear function time over. Time for the full curve now.
        // Firstly, intersection with y=0 and y=1. We can solve for x:
        //   x = -(y*c + d) / (y*a + b) = g(y)
        //
        // ... so about intersections... A hyperbola will intersect all lines parallel to the x axis, except one:
        // its pole. So if the pole is either y=0 or y=1, then we have a problem, and we need to handle this case.
        // That's the "between 1 and 2 intersection points" from before.

        enum IntersectionPoints {
            Zero,
            One(f32),
            Two(f32, f32),
        }
        // x coordinates of the intersection points with y=0 and y=1
        let intersection_points = if b.abs() < EPSILON {
            // the pole is at y=0. We only have one intersection point.
            IntersectionPoints::One(-(c + d) / (a + b))
        } else if (a + b).abs() < EPSILON {
            // the pole is at y=1. We only have one intersection point.
            IntersectionPoints::One(-d / b)
        } else {
            IntersectionPoints::Two(-(c + d) / (a + b), -d / b)
        };

        if let IntersectionPoints::Two(i1, i2) = intersection_points {
            if (i1 - i2).abs() < EPSILON {
                // Here's another special case: if both intersection points have the same x value, then the "curve" is
                // a cross that divides the plane into 4 quadrants. In that case, our cool integral is useless, because
                // the function isn't continuous.
                // Luckily, a cross is a very simple shape. The cross is defined by the 2 poles (in x and y) of the
                // hyperbola, so we just need to find the center point of the cross. We already found the x coordinate,
                // now for y.
                //   g(y) = -(y*c + d) / (y*a + b)
                // We just need to make y*a+b zero. a!=0, so we get y=-b/a.
                let center_x = (i1 + i2) * 0.5;
                let center_y = -b / a;

                // The center might be outside, and we have to handle that...
                if !ZERO_TO_ONE.contains(&center_x) {
                    if !ZERO_TO_ONE.contains(&center_y) {
                        // the center is completely outside the square. The area is either 0 or 1.
                        return if sample_middle() { 1.0 } else { 0.0 };
                    } else {
                        // we just see a line at y=center_y.
                        //   sample(x=0.5,y=0)-threshold = x*y*a + x*b + y*c + d = 0.5*b + d
                        let area = center_y;
                        return if 0.5 * b + d > 0.0 { area } else { 1.0 - area };
                    }
                } else {
                    // center_x is inside the square.
                    if !ZERO_TO_ONE.contains(&center_y) {
                        // we just see a line at x=center_x.
                        //   sample(x=0,y=0.5)-threshold = x*y*a + x*b + y*c + d = 0.5*c + d
                        let area = center_x;
                        return if 0.5 * c + d > 0.0 { area } else { 1.0 - area };
                    } else {
                        // the entire cross is inside the square.
                        // Also, the cross makes a checker-board pattern for the area, so we just need to check the threshold
                        // at any of the 4 corners of the square. We'll go with sample(x=0,y=0)-threshold = d.
                        let checker_area_00 =
                            center_x * center_y + (1.0 - center_x) * (1.0 - center_y);
                        return if d > 0.0 {
                            checker_area_00
                        } else {
                            1.0 - checker_area_00
                        };
                    }
                }
            }
        }

        // discard intersection points outside of the square (or on its line)
        let intersection_points = match intersection_points {
            IntersectionPoints::Zero => IntersectionPoints::Zero,
            IntersectionPoints::One(i1) => {
                if !ZERO_TO_ONE.contains(&i1) {
                    IntersectionPoints::Zero
                } else {
                    IntersectionPoints::One(i1)
                }
            }
            IntersectionPoints::Two(i1, i2) => {
                if !ZERO_TO_ONE.contains(&i1) {
                    if !ZERO_TO_ONE.contains(&i2) {
                        IntersectionPoints::Zero
                    } else {
                        IntersectionPoints::One(i2)
                    }
                } else if !ZERO_TO_ONE.contains(&i2) {
                    IntersectionPoints::One(i1)
                } else {
                    IntersectionPoints::Two(i1, i2)
                }
            }
        };

        // function to compute the area of each segment
        let compute_area = |x1: f32, x2: f32| {
            // The segment is either:
            //   a. an area with all the same threshold value, or
            //   b. an area that is cut by a line.
            // The integral is only correct for case b, and case a is trivial. So we need to figure out which case we
            // have. This is also pretty easy. We just compare the thresholds in the middle of the segment at y=0 and
            // y=1. If they are the same, then it's a. Otherwise, it's b.
            let x_mid = (x1 + x2) * 0.5;
            let y0 = x_mid * b + d;
            let y1 = x_mid * a + x_mid * b + c + d;

            // the threshold curve might be exactly on y=0 or y=1, so we have to handle y0=0 and y1=1 separately.
            let y0_zero = y0.abs() < EPSILON;
            let y1_zero = y1.abs() < EPSILON;
            let (y0, y1) = match (y0_zero, y1_zero) {
                (true, true) => {
                    // this is tricky. We know that the curve can't be 0 for both values, so we'll do a true zero
                    // check to resolve this.
                    match (y0 == 0.0, y1 == 0.0) {
                        (true, true) => (false, false),
                        (true, false) => (y1 > 0.0, y1 > 0.0),
                        (false, true) => (y0 > 0.0, y0 > 0.0),
                        (false, false) => (y0 > 0.0, y1 > 0.0),
                    }
                }
                (true, false) => (y1 > 0.0, y1 > 0.0),
                (false, true) => (y0 > 0.0, y0 > 0.0),
                (false, false) => (y0 > 0.0, y1 > 0.0),
            };

            let total_area = x2 - x1;
            let area = if y0 == y1 {
                // case a
                total_area
            } else {
                // case b
                //
                // Now we can finally use the area(n=x1,m=x2)
                ((b * c - a * d) * f32::ln((a * x2 + c) / (a * x1 + c)) - a * b * (x2 - x1))
                    / (a * a)
            };

            if y0 {
                area
            } else {
                total_area - area
            }
        };

        match intersection_points {
            IntersectionPoints::Zero => compute_area(0.0, 1.0),
            IntersectionPoints::One(i1) => compute_area(0.0, i1) + compute_area(i1, 1.0),
            IntersectionPoints::Two(i1, i2) => {
                let min = i1.min(i2);
                let max = i1.max(i2);
                compute_area(0.0, min) + compute_area(min, max) + compute_area(max, 1.0)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::BiLinear;

    #[test]
    fn area_exact() {
        // the threshold will always be 0.5 in this test
        const T: f32 = 0.5;

        let exact_area: Vec<(f32, BiLinear)> = vec![
            // some relatively trivial cases
            (0.0, BiLinear::new(0.0, 0.0, 0.0, 0.0)),
            (0.0, BiLinear::new(0.5, 0.5, 0.5, 0.5)),
            (1.0, BiLinear::new(0.5001, 0.5, 0.5, 0.5)),
            (1.0, BiLinear::new(0.5001, 0.5001, 0.5001, 0.5001)),
            (1.0, BiLinear::new(1.0, 1.0, 1.0, 1.0)),
            // crosses and straight lines
            (0.5, BiLinear::new(1.0, 1.0, 0.0, 0.0)),
            (0.5, BiLinear::new(1.0, 0.0, 1.0, 0.0)),
            (0.5, BiLinear::new(0.0, 1.0, 1.0, 0.0)),
            (0.5, BiLinear::new(1.0, 0.0, 0.0, 1.0)),
            (0.5, BiLinear::new(0.0, 0.0, 1.0, 1.0)),
            (0.5, BiLinear::new(0.0, 1.0, 0.0, 1.0)),
        ];

        for (expected, bilinear) in exact_area {
            let actual = bilinear.get_area(T);
            assert!(
                actual == expected,
                "Expected the exact area of {:?} to be {}, but got {}",
                bilinear,
                expected,
                actual
            );
        }

        // well, this is pretty much fuzzing, but brute force
        let steps = 10;
        for x0y0 in 0..=steps {
            for x1y0 in 0..=steps {
                for x0y1 in 0..=steps {
                    for x1y1 in 0..=steps {
                        let bilinear = BiLinear::new(
                            x0y0 as f32 / steps as f32,
                            x1y0 as f32 / steps as f32,
                            x0y1 as f32 / steps as f32,
                            x1y1 as f32 / steps as f32,
                        );

                        let actual = bilinear.get_area(T);
                        // 32*32 samples should get us within 1% of the exact area
                        let expected = bilinear.get_area_samples::<64>(T);

                        let diff = (actual - expected).abs();

                        // if diff >= 0.01 {
                        //     // for debugging
                        //     let area = bilinear.get_area_exact(T);
                        // }

                        assert!(
                            diff < 0.01,
                            "Expected the exact area of {:?} to be {} +-1%, but got {} (abs diff={})",
                            bilinear,
                            expected,
                            actual,
                            diff
                        );
                    }
                }
            }
        }

        // This one has a funny shape. It looks roughly like this for a threshold of 0.5:
        //   1 1 1 0 0 0 0 0
        //   1 1 1 0 0 0 0 0
        //   1 1 1 1 1 1 1 0
        //   0 0 1 1 1 1 1 1
        //   0 0 1 1 1 1 1 1
        //   0 0 1 1 1 1 1 1
        //   0 0 1 1 1 1 1 1
        //   0 0 1 1 1 1 1 1
        // It's area is around 0.65
        let b1 = BiLinear {
            x0y0: 0.63,
            x1y0: 0.27,
            x0y1: 0.28,
            x1y1: 1.0,
        };

        assert!((b1.get_area(0.5) - 0.65).abs() < 0.04);
    }
}
